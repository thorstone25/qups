function [cxy, ixo, iyo, iro] = wbilerpg(x, y, xa, ya, xb, yb, r)
% WBILERPG - Weights for bilinear interpolation (GPU/OpenCL-enabled)
%
% [cxy, ixo, iyo] = WBILERPG(x, y, xa, ya, xb, yb) takes in a pair of grid
% vectors x, y and an array of pairs of endpoints (xa,ya) to (xb,yb) and
% returns the interpolation weights cxy, the x-indices ixo, and the
% y-indices iyo that describe the bi-linear inteprolation weights for each
% segment of the line from (xa,xb) to (xb,yb) as it intersects the x-grid
% and y-grid and their indices on the x-grid and y-grid. The arrays xa, ya,
% xb, yb must all be the same size.
%
% Each output is size [4 x (X + Y + 1)] x size(xa, 1:ndims(xa)) where X and
% Y are the length of the x and y vectors. The indices ixo and iyo are
% 1-based. If the index is invalid, ixo and iyo are 0. Multiple idenitcal
% indices represent contributions from different line segments intersecting
% the same grid index. These can be added afterwards to form the full
% weights.
%
% [...] = WBILERP(x, y, xa, ya, xb, yb, r) specifies a vector of segment
% divisions r that sub-divide the line (xa,ya) to (xb,yb) by inserting the
% points (xa + r(i)*(xb-xa), ya + r(i)*(yb-ya)) where r must be between 0
% and 1 exclusively. Each output is then size 4 x (X + Y + R + 1) where R
% is the number of sub-divisions. The default is [] (no sub-divisions).
% 
% [cxy, ixo, iyo, iro] = WBILERP(...) additionally outputs an ND-array of
% indices corresponding to each line segment defined by the subdivisions in
% r. A value of 0 indicates the index is invalid. These can be used to
% generate multiple sets of weights along the same line.
% 
% Note: This function requires that either a CUDA-enabled gpu or a working
% implementation of OpenCL via Matlab-OpenCL be available.
% 
% The following example shows how a sparse matrix can be generated by
% implicitly adding overlapping pixel weights.
%
% Example:
% % Create a grid
% [x, y] = deal(-5:5, -5:5); % 11 x 11 grid
% [xa, ya] = deal(-4, +1);
% [xb, yb] = deal(+3, -2);
%
% % Get the interpolation weights
% [cxy, ixo, iyo] = wbilerpg(x, y, xa, ya, xb, yb); % get the line segment weights
% 
% % Create a sparse matrix, implicitly summing weights from neighboring
% % line segments
% val = (ixo ~= 0) & (iyo ~= 0); % filter out invalid indices
% s = sparse(ixo(val), iyo(val), cxy(val), numel(x), numel(y));
% 
% figure;
% pcolor(x, y, full(s)')
% title("Weights from ("+xa+","+ya+"), to ("+xb+","+yb+").");
% clim([0 1]);
% 
% % Example 2: Line segments
% % Divide the line into quarters
% r = [1/4, 1/2, 3/4]; % divisions (endpoints 0 and 1 are implicit)
% [cxy, ixo, iyo, iro] = wbilerpg(x, y, xa, ya, xb, yb, r); % get the line segment weights
% for i = 1:4, val = (iro == i); 
%     si{i} = sparse(ixo(val), iyo(val), cxy(val), numel(x), numel(y));
% end
% 
% % Display
% figure; tiledlayout('flow');
% for i = 1:4
%     h(i) = pcolor(nexttile(i), x, y, full(si{i})');
%     clim(h(i).Parent, [0 1]);
%     title(h(i).Parent, "Line segment "+i+" of 4" ... 
%         + " from ("+xa+","+ya+"), to ("+xb+","+yb+")." ...
%     );
%     seg_len(i) = full(sum(si{i},'all'));
% end
% 
% seg_len = cellfun(@(S) full(sum(S,'all')), si);
% disp("Segment lengths: [" + join(string(seg_len),", ") + "]");
% disp("Range (max - min): " + range(seg_len));
% 
% See also XIAOLINWU_K_SCALED SPARSE WBILERP

arguments
    x (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    y (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    xa      {mustBeReal, mustBeNumeric, mustBeFloat}
    ya      {mustBeReal, mustBeNumeric, mustBeFloat}
    xb      {mustBeReal, mustBeNumeric, mustBeFloat}
    yb      {mustBeReal, mustBeNumeric, mustBeFloat}
    r  (:,1) {mustBeInRange(r,0,1), mustBeFloat} = [] % segment divisions
end

% ensure floating point, sorted, grid in vector form
assert(issorted(x), 'x-grid vector must be sorted.');
assert(issorted(y), 'y-grid vector must be sorted.');
assert(isscalar(unique(cellfun(@ndims, {xa,ya,xb,yb}))), 'All end-point coordinates must have the same number of dimensions.')
assert(~any(diff(cell2mat(cellfun(@(x){size(x)'}, {xa,ya,xb,yb})),1,2),'all'), 'All end-point coordinates must have the same size.')

% move to same class to avoid precision matching issues
proto = cat(1,x([]),y([]),xa([]),ya([]),xb([]),yb([])); % imply MATLAB casting rules
iproto = int32(proto); % integer version (gpuArray maybe?)
[x,y,xa,ya,xb,yb] = deal6fun(@(x)cast(x, 'like', proto),x,y,xa,ya,xb,yb);

% get the transforms that should be applied for each set of points
[yneg, steep, reverse] = arrayfun(@getTrans, xa, ya, xb, yb);

% pre-allocate final output
Ia = numel(xa); % number of point pairs
N = numel(x) + numel(y) + numel(r) + 1; % number of grid points
[ixo, iyo] = deal(zeros([4,N,Ia], 'like', iproto));
[iro     ] = deal(zeros([1,N,Ia], 'like', iproto));
[cxy]      = deal(zeros([4,N,Ia], 'like',  proto));

% determine the suffix based on the type
uclass = class(xa);
if uclass == "gpuArray", uclass = classUnderlying(xa); end
switch uclass
    case "double",prc = 64; suffix = "";
    case "single",prc = 32; suffix = "f";
    case "halfT", prc = 16; suffix = "h"; cxy = alias(cxy); % ensure aliased - we can index directly
end

% parse device
use_gdev = canUseGPU() && exist('wbilerp.ptx', 'file');
use_odev = exist('oclDeviceCount','file') && oclDeviceCount() && ~isempty(oclDevice());

% specify the kernel (must be on the path)
if use_gdev
    % reference kernel
    kern = parallel.gpu.CUDAKernel('wbilerp.ptx', 'wbilerp.cu', "wbilerp" + suffix);
elseif use_odev
    % reference kernel
    kern = oclKernel('wbilerp.cl');

    % specify aliased types
    kern.defineTypes({uclass});
    kern.macros(end+1) = "QUPS_PRECISION="+prc;

    % validate precision support
    if   (uclass == "double") && (~kern.Device.SupportsDouble) ...
            || (uclass == "halfT") && (~kern.Device.SupportsHalf)
        error("QUPS:wbilerpg:precisionNotSupported", ...
            "Device " + kern.Device.Index + " (" + kern.Device.Name + ") " + ...
            "does not support " + uclass + " precision." ...
            );
    end
else
    % no kernel device found
    error("QUPS:wbilerpg:supportedDeviceNotFound", ...
        "wbilerpg() requires either a supported CUDA enabled GPU " + ...
        "or a working OpenCL implementation via Matlab-OpenCL. Use wbilerp instead." ...
        );
end

% proceed by which transform should be applied
for ineg = [false, true], for isteep = [false, true], for irev = [false, true]

            % indices matching this tranform
            ind = yneg == ineg & isteep == steep & irev == reverse;
            I = nnz(ind);

            % if no data follows this transform, skip this batch
            if I == 0, continue; end

            % transform: sort coordinates and endpoints
            [ux, uy, vx, vy, xg, yg] = applyTrans(xa(ind), ya(ind), xb(ind), yb(ind), x, y, ineg, isteep, irev);

            % now, we have ux <= vx, |dy| <= |dx|, 0 <= dy/dx <= 1
            % get the gradient
            m  = ((vy - uy) ./ (vx - ux));

            % get the inverse gradient
            mi = ((vx - ux) ./ (vy - uy));
            mi(vy == uy) = nan;

            % min/max values supported on the grid/line
            pml = complex(max(xg(1  ), ux), max(yg(1  ), uy)); % lower bound (1 x I)
            pmu = complex(min(xg(end), vx), min(yg(end), vy)); % upper bound (1 x I)

            % sort in x, then y, so that we have a non-descreasing line
            [ux, uy, vx, vy, m, mi] = dealfun(@(x) reshape(x,1,1,I), ux, uy, vx, vy, m, mi); % move to 1 x 1 x I

            % all points ([N+1] x 2 x I)
            pall = [...
                ux + r.*(vx-ux), uy + r.*(vy-uy); ... segments
                ux, uy; ... endpoint
                vx, vy; ... endpoint
                [xg + 0*uy, uy + m  .* (xg - ux)]; ...  x-intercepts
                [ux + mi .* (yg - uy), yg + 0*uy]; ...  y-intercepts
                ];

            % input/output sizing
            X = cast(numel(xg), 'like', iproto);
            Y = cast(numel(yg), 'like', iproto);
            R = cast(numel(r ), 'like', iproto);
            % N = X + Y + R + 1;

            % sort, reshape, and label all points / segments
            n_ = (ones(1,'like',iro):N)'; % indices
            [pall, oi] = sortpoints(pall, m); % sort x/y per I ([N+1] x 2 x I)
            pall = reshape(complex(pall(:,1,:), pall(:,2,:)),[1 N+1,I]); % (1 x [N+1] x I)
            oj = (argmax(oi == [R+1, (1:R), R+2],[],1)); % label transitions (1 x [R+2] x I)
            % oj = (oj(:,1:end-1,:) <= n_ & n_ <= oj(:,2:end,:)); % label filters (N x [R+1] x I)
            % for l = 1:R+1, iro(1,oj(:,l,:)) = l; end % set labels
            % iro(:,:,ind) = reshape(sum((1:R+1) .* int32(oj), 2, "native"), [1 N I]); % labels (1 x N x I)
            iro(1,:,ind) = sum( (1:R+1) .* cast(...
                oj(:,1:end-1,:) <= n_ & n_ < oj(:,2:end,:) ...
                , 'like', iproto), 2, "native"); % inline labels: (N x 1 x I) -> (1 x N x I)
            %{
            % sort and reshape them -> (2 x [N+1] x I)
            [pall, m, iro_] = gather(pall, m, iro(:,:,ind));
            parfor (i = 1:I)
            % for (i = 1:I)
                [pall(:,:,i), oi] = sortpoints(pall(:,:,i), m(i)); % sort
                oj = arrayfun(@(x) find(oi == x,1,'first'), [R+1, (1:R), R+2]); % start | segments | end
                iroi_ = iro_(1,:,i); % splicing
                for j = 1:R+1, iroi_(oj(j) : oj(j+1) - 1) = j; end % label
                iro_(1,:,i) = iroi_; % update
            end 
            iro(:,:,ind) = iro_; 
            pall = pagetranspose(pall);
            pall = complex(pall(1,:,:), pall(2,:,:)); % typecast
            %}

            % preallocate output: each line segment produces 4 integrals for 4 grid
            % points defined by [[ix, iy, c1]; [ix+1, iy, c2]; [ix, iy+1, c3], [ix+1, iy+1, c4]];
            cxyo = zeros([4,N,I], 'like', real(pall([])));
            ixyo = -gpuArray.ones(1,underlyingType(iproto));
            ixyo = repmat(complex(ixyo, ixyo), [4,N,I]); % alias (x,y) -> (real, imag)

            % setup the execution size
            kern.ThreadBlockSize(1) = min(I,kern.MaxThreadsPerBlock);
            kern.GridSize = [ceil(I / kern.ThreadBlockSize(1)), 1, 1];

            % run the kernel
            if suffix ~= "h"
                [ixyo, cxyo] = kern.feval(ixyo, cxyo, pall, xg, yg, X, Y, I, pml, pmu);
            else
                [cxyo, pall, xg, yg, pml, pmu] = dealfun(@alias, cxyo, pall, xg, yg, pml, pmu);
                [ixyo, cxyo] = kern.feval( ...
                    ixyo, cxyo.val, pall.val, ...
                    xg.val, yg.val, X, Y, I, ...
                    pml.val, pmu.val ...
                    );
            end

            % set correct output for x and y in original coordinates
            [ixo(:,:,ind), iyo(:,:,ind)] = unapplyTrans(real(ixyo), imag(ixyo), ineg, isteep, Y);
            if suffix ~= "h", cxy(:,:,ind) = cxyo; % store normally
            else,             cxy.val(:,:,ind) = cxyo; % store while aliased
            end

end, end, end

% set output sizing as a vector in dim1
osz = [4*N, size(xa, 1:ndims(xa))];
iro = repmat(iro, [4,1]); % expand
[ixo, iyo, iro, cxy] = deal4(reshape(ixo,osz), reshape(iyo,osz), reshape(iro,osz), reshape(cxy,osz));
ixo = ixo + 1; iyo = iyo + 1; % use 1-based indexing for MATLAB

% set invalid indices to 0:
iro = iro .* cast(ixo & iyo, 'like', iproto);
% assert(~any(iro & ~(ixo&iyo),'all'), "Labelled segment contains invalid points!"); % DEBUG: has label -> valid point
end

% helper functions
function [a,b] = deal2(a,b), end
function [a,b,c,d] = deal4(a,b,c,d), end
function [a,b,c,d,e,f] = deal6(a,b,c,d,e,f), end
function [a,b,c,d,e,f] = deal6fun(fun,a,b,c,d,e,f)
a = fun(a); b = fun(b); c = fun(c); d = fun(d); e = fun(e); f = fun(f);
end


function [pall, o] = sortpoints(pall, m)
% sort in x, then y, so that we have a non-descreasing line
% [pall, o] = sortrows(pall, [1, 2], 'ascend'); % sort in x, then y ([N+1] x 2)
[~, o] = sort(pall(:,1,:), 1, 'ascend'); % sort in x, then y ([N+1] x 2 x I)
pall = sel(pall, o, 1);
o = int32(o);

% when points are very close but not equal, numerical instability can cause
% things to be non-monotonic: enforce this by sorting y separately from x
% unless m = 0 / mi = nan. This swaps y-values when they are mismatched due
% to numerical instability.
% if ~(m == 0), pall(:,2) = sort(pall(:,2), 'ascend'); end
i = ~(m == 0);
[~, j] = sort(pall(:,2,i), 1, 'ascend');
pall(:,2,i) = sel(pall(:,2,i), j, 1);
end

function [yneg, steep, reverse] = getTrans(xa, ya, xb, yb)
% get coordinate transformation for this set of points

% if slope is negative, we negate y
yneg = (((yb - ya) / (xb - xa)) < 0) || (((xb - xa) / (yb - ya)) < 0);

% whether to swap x/y axis
steep = abs(yb - ya) > abs(xb - xa);

% whether to swap a/b order
if steep, reverse = ya > yb; else, reverse = xa > xb; end
end

function [ux, uy, vx, vy, xg, yg] = applyTrans(xa, ya, xb, yb, x, y, yneg, steep, reverse)
% apply coordinate transformations to this set of points

% sort coordinates and endpoints
if yneg
    if      steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(yb, -xb, ya, -xa, y, flip(-x));
    elseif  steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(ya, -xa, yb, -xb, y, flip(-x));
    elseif ~steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xb, -yb, xa, -ya, x, flip(-y));
    else % ~steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xa, -ya, xb, -yb, x, flip(-y));
    end
else
    if      steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(yb, xb, ya, xa, y, x);
    elseif  steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(ya, xa, yb, xb, y, x);
    elseif ~steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xb, yb, xa, ya, x, y);
    else % ~steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xa, ya, xb, yb, x, y);
    end
end

end

function [ixo, iyo] = unapplyTrans(ixo, iyo, yneg, steep, Y)
% set correct output for x and y in original coordinates
if yneg, j = iyo > 0; iyo(j) = (Y - 1) - iyo(j); end
if steep, [ixo, iyo] = deal2(iyo, ixo); end

end


