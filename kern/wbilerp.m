function [cxy, ixo, iyo, iro] = wbilerp(x, y, xa, ya, xb, yb, r)
% WBILERP - Weights for bilinear interpolation
%
% [cxy, ixo, iyo] = WBILERP(x, y, xa, ya, xb, yb) takes in a pair of grid 
% vectors x, y and a pair of endpoints (xa,ya) to (xb,yb) and returns the 
% interpolation weights cxy, the x-indices ixo, and the y-indices iyo that
% describe the bi-linear inteprolation weights for each segment of the line
% from (xa,xb) to (xb,yb) as it intersects the x-grid and y-grid and their
% indices on the x-grid and y-grid. 
% 
% Each output is size 4 x (X + Y + 1) where X and Y are the length of the 
% x and y vectors. The indices ixo and iyo are 1-based. If the index is
% invalid, ixo and iyo are 0. Multiple identical indices represent 
% contributions from different line segments intersecting the same grid 
% index. These can be added afterwards to form the full weights.
% 
% [...] = WBILERP(x, y, xa, ya, xb, yb, r) specifies a vector of segment
% divisions r that sub-divide the line (xa,ya) to (xb,yb) by inserting the
% points (xa + r(i)*(xb-xa), ya + r(i)*(yb-ya)) where r must be between 0
% and 1 exclusively. Each output is then size 4 x (X + Y + R + 1) where R
% is the number of sub-divisions. The default is [] (no sub-divisions).
% 
% [cxy, ixo, iyo, iro] = WBILERP(...) additionally outputs an ND-array of
% indices corresponding to each line segment defined by the subdivisions in
% r. A value of 0 indicates the index is invalid. These can be used to
% generate multiple sets of weights along the same line.
% 
% The following example shows how a sparse matrix can be generated by
% implicitly adding overlapping pixel weights.
%
% Example:
% % Create a grid
% [x, y] = deal(-5:5, -5:5); % 11 x 11 grid
% [xa, ya] = deal(-4, +1);
% [xb, yb] = deal(+3, -2);
%
% % Get the interpolation weights
% [cxy, ixo, iyo] = wbilerp(x, y, xa, ya, xb, yb); % get the line segment weights
% 
% % Create a sparse matrix, implicitly summing weights from neighboring
% % line segments
% val = (ixo ~= 0) & (iyo ~= 0); % filter out invalid indices
% s = sparse(ixo(val), iyo(val), cxy(val), numel(x), numel(y));
% 
% figure;
% pcolor(x, y, full(s)')
% title("Weights from ("+xa+","+ya+"), to ("+xb+","+yb+").");
% caxis([0 1]);
% 
% % Example 2: Line segments
% % Divide the line into quarters
% r = [1/4, 1/2, 3/4]; % divisions (endpoints 0 and 1 are implicit)
% [cxy, ixo, iyo, iro] = wbilerp(x, y, xa, ya, xb, yb, r); % get the line segment weights
% for i = 1:4, val = (iro == i); 
%     si{i} = sparse(ixo(val), iyo(val), cxy(val), numel(x), numel(y));
% end
% 
% % Display
% figure; tiledlayout('flow');
% for i = 1:4
%     h(i) = pcolor(nexttile(i), x, y, full(si{i})');
%     caxis(h(i).Parent, [0 1]);
%     title(h(i).Parent, "Line segment "+i+" of 4" ... 
%         + " from ("+xa+","+ya+"), to ("+xb+","+yb+")." ...
%     );
%     seg_len(i) = full(sum(si{i},'all'));
% end
% 
% seg_len = cellfun(@(S) full(sum(S,'all')), si);
% disp("Segment lengths: [" + join(string(seg_len),", ") + "]");
% disp("Range (max - min): " + range(seg_len));
% 
% See also XIAOLINWU_K_SCALED SPARSE WBILERPG

arguments
    x  (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    y  (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    xa (1,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    ya (1,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    xb (1,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    yb (1,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    r  (:,1) {mustBeInRange(r,0,1), mustBeFloat} = [] % segment divisions
end

% ensure floating point, sorted, grid in vector form
assert(issorted(x, 'strictmonotonic'), 'x-grid vector must be sorted and monotonic.');
assert(issorted(y, 'strictmonotonic'), 'y-grid vector must be sorted and monotonic.');

% move to same class to avoid precision matching issues
proto = cat(1,x([]),y([]),xa([]),ya([]),xb([]),yb([])); % imply MATLAB casting rules
[x,y,xa,ya,xb,yb] = deal6fun(@(x)cast(x, 'like', proto),x,y,xa,ya,xb,yb);

% if slope is negative, we negate y
yneg = (((yb - ya) / (xb - xa)) < 0) || (((xb - xa) / (yb - ya)) < 0);

% whether to swap x/y axis
steep = abs(yb - ya) > abs(xb - xa);

% whether to swap a/b order
if steep, reverse = ya > yb; else, reverse = xa > xb; end

% sort coordinates and endpoints
if yneg
if      steep &&  reverse
    [ux, uy, vx, vy, xg, yg] = deal6(yb, -xb, ya, -xa, y, flip(-x));
elseif  steep && ~reverse
    [ux, uy, vx, vy, xg, yg] = deal6(ya, -xa, yb, -xb, y, flip(-x));
elseif ~steep &&  reverse
    [ux, uy, vx, vy, xg, yg] = deal6(xb, -yb, xa, -ya, x, flip(-y));
else % ~steep && ~reverse
    [ux, uy, vx, vy, xg, yg] = deal6(xa, -ya, xb, -yb, x, flip(-y));
end
else
if      steep &&  reverse
    [ux, uy, vx, vy, xg, yg] = deal6(yb, xb, ya, xa, y, x);
elseif  steep && ~reverse
    [ux, uy, vx, vy, xg, yg] = deal6(ya, xa, yb, xb, y, x);
elseif ~steep &&  reverse
    [ux, uy, vx, vy, xg, yg] = deal6(xb, yb, xa, ya, x, y);
else % ~steep && ~reverse
    [ux, uy, vx, vy, xg, yg] = deal6(xa, ya, xb, yb, x, y);
end
end

% now, we have ux <= vx, |dy| <= |dx|, 0 <= dy/dx <= 1
% get the gradient
m  = ((vy - uy) / (vx - ux));

% get the inverse gradient
if vy == uy
    mi = nan;
else 
    mi = ((vx - ux) / (vy - uy));
end

% min/max values supported on the grid/line
pm = [...
    [max(xg(1),ux), min(xg(end),vx)]; ... % xmin, xmax
    [max(yg(1),uy), min(yg(end),vy)]  ... % ymin, ymax
    ];

% input/output sizing
R = uint32(numel(r));
X = uint32(numel(xg));
Y = uint32(numel(yg));
N = X + Y + R + 1;

% starting indices for the grid
ix = uint32(1);  
iy = uint32(1); 

% preallocate output: each line segment produces 4 integrals for 4 grid
% points defined by [[ix, iy, c1]; [ix+1, iy, c2]; [ix, iy+1, c3], [ix+1, iy+1, c4]];
cxy = zeros([4,N], 'like',  pm);
ixo = zeros([4,N], 'uint32');
iyo = zeros([4,N], 'uint32');
iro = zeros([1,N], 'uint32');

% sort in x, then y, so that we have a non-descreasing line
[pall, o] = sortrows([...
    ux + r .* (vx - ux), uy + r .* (vy - uy); ... segments (endpoints excluded)
    ux, uy; ... endpoint (start)
    vx, vy; ... endpoint (end)
    [xg, uy + m  .* (xg - ux)]; ...  x-intercepts
    [ux + mi .* (yg - uy), yg]; ...  y-intercepts
    ], ...
    [1, 2] ... sort in x, then y
    ); %(2 x [N+1])

% label each segment
o = arrayfun(@(x)find(o == x,1,'first'), [R+1, (1:R), R+2]); % start | segments | end
for i = 1:R+1, iro(o(i) : o(i+1)) = i; end

% when points are very close but not equal, numerical instability can cause 
% things to be non-monotonic: enforce this by sorting y separately 
% unless m = 0 / mi = nan
if ~(m == 0), pall(:,2) = sort(pall(:,2), 'ascend'); end
pall = pall';

% splice for (potential) MATLAB performance
p1all = pall(:,1:end-1);
p2all = pall(:,2:end);

% compute all integrals and indices
for n = 1 : N
    % get both points (x/y by pair)
    p1   = p1all(:,n);
    p2   = p2all(:,n);
    ploc = [p1, p2];
    % sel  = o(n:n+1); % selected point
        
    % length of the line segment
    l = hypot(p2(1) - p1(1), p2(2) - p1(2));
       
    % if points are within the support of the grid / line
    val = all(pm(:,1) <= ploc & ploc <= pm(:,2), 'all');
      
    % skip integral if out of grid / line support, the segment length is zero, or if co-located in x
    if ~val || l == 0 || p2(1) == p1(1), iro(n) = 0; continue, end
    
    % reinitialize: enables parfor behaviour, but that is a much slower
    % parallelization than just looping this function
    % ix = int32(1);  if ydir, iy = int32(1); else, iy = Y-1; end % starting indices for the grid
    
    % if any point not in x/y-bounds, move to next x/y-grid interval
    while ((p1(1) >= xg(ix+1)) && (p2(1) >= xg(ix+1)) && (ix+2 <= X)), ix=ix+1; end
    while ((p1(2) >= yg(iy+1)) && (p2(2) >= yg(iy+1)) && (iy+2 <= Y)), iy=iy+1; end
    
    % get the indices for each of the four grid points affected by this 
    % line segment
    ixloc = [ix, ix+1, ix, ix+1]; % x index
    iyloc = [iy, iy, iy+1, iy+1]; % y index
    
    % grid points 
    q = [xg(ixloc)'; yg(iyloc)']; % (2 x 4)
    
    % get the line segment region's size
    dp = [xg(ix+1)-xg(ix); yg(iy+1)-yg(iy)];
    
    %%% inline the integral %%%
    % s_d == -1 if in positive quadrant of dimension d
    s = 2 * ((p1 <= q) & (p2 <= q)) - 1; % (2 x 4)
    
    % coefficients for the integral
    a = 1 + s .* (p1 - q ) ./ dp;
    b =     s .* (p1 - p2) ./ dp;
    
    % evaluation of the integral: subject to numerical precision issues
    c = prod(a,1) - sum(a .* flip(b,1),1) ./ 2.0 + prod(b,1) ./ 3.0;
    
    % apply line integral formula w/r to quadrant
    ixo(:,n) = ixloc;
    iyo(:,n) = iyloc;
    cxy(:,n) = l * c;
end

% set correct output for x and y in original coordinates
if yneg, iyo(iyo > 0) = (1 + Y) - iyo(iyo > 0); end
if steep, [ixo, iyo] = deal(iyo, ixo); end

% set output sizing as a vector
iro = repmat(iro,[4,1]);
[iro, ixo, iyo, cxy] = deal(iro(:), ixo(:), iyo(:), cxy(:));

end

% helper functions
function [a,b,c,d,e,f] = deal6(a,b,c,d,e,f), end
function [a,b,c,d,e,f] = deal6fun(fun,a,b,c,d,e,f)
    a = fun(a); b = fun(b); c = fun(c); d = fun(d); e = fun(e); f = fun(f);
end


